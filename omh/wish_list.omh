$Id$
/* --------------------------------------------------------------------------
CppAD: C++ Algorithmic Differentiation: Copyright (C) 2003-15 Bradley M. Bell

CppAD is distributed under multiple licenses. This distribution is under
the terms of the
                    Eclipse Public License Version 1.0.

A copy of this license is included in the COPYING file of this distribution.
Please visit http://www.coin-or.org/CppAD/ for information on other licenses.
-------------------------------------------------------------------------- */
$begin WishList$$
$spell
	op
	Recomputation
	jacobian
	nz
	RevSparseJac
	optimizer
	Rel
	Gt
	Eq
	CondExpLt
	Checkpointing
	grep
	recomputed
	afun
	iterator
	std
	cos
	Adolc
	xml
	hpp
	CppAD
	Atan
	cppad
	mul
	div
	instantiate
	instantiation
	Bool
$$

$section The CppAD Wish List$$

$head Optimize Atomic Operations$$
Use the current $cref atomic_option$$ setting to determine
which type of sparsity patterns to use for
$cref/dependency/dependency.cpp/$$ calculations during
$cref optimize$$ procedure.
In addition, use forward mode, instead of reverse, when it is more efficient
for the dependency calculations.

$head checkpoint$$
There should be some examples and tests for both speed and memory use
that demonstrate that checkpointing is useful.

$head abort_op_index$$
When a known error is detected during $cref forward$$ or $cref reverse$$ mode,
include the operator index in the output error message. (For example,
when taking the derivative of the square root function at zero.)
The syntax
$codei%
	Independent(%x%, %abort_op_index%)
%$$
could then be used to find the corresponding user source code; see
$cref/abort_op_index/Independent/abort_op_index/$$.

$head Absolute Zero$$
Currently, one must use the $cref zdouble$$ class for
$cref mul_level$$ AD that uses $cref/conditional expressions/CondExp/$$
and $cref reverse$$ mode.
Perhaps it would be better to use special functions; e.g.,
$code abs_zero_mul$$ and $code abs_zero_div$$,
so that not all multiplies and divides would need to check for zero
(in the multiple level AD with conditional expressions and reverse mode case).

$head Numeric Limits$$
Define a specialization for
$codei%
	std::numeric_limits< CppAD::AD<%Base%> >
%$$
This seems to be OK according to the following paragraph from Section
17.6.4.2.1 of the C++11 standard (Document number N3336)
`A program may explicitly instantiate a template defined in the
standard library only if the declaration depends on the name of a
user-defined type and the instantiation meets the
standard library requirements for the original template.'

$head Machine Epsilon in Examples$$
Use a multiple of $code std::numeric_limits<double>::epsilon()$$ instead
$code 1e-10$$ for a small number in correctness checks; e.g.,
see $cref sqrt.cpp$$.

$head Adolc$$
Create a documentation page that shows how to convert Adolc commands to
CppAD commands.

$head Optimizing Nested Conditional Expressions$$
If one $cref/optimizes/optimize/$$ the code
$codep
	x = CondExpLt(left_x, right_x, true_x, false_x)
	y = CondExpGt(left_y, right_y, true_y, false_y)
	z = CondExpEq(left_z, right_z, x, y)
$$
only two of the expressions
$code true_x$$, $code false_x$$, $code true_y$$, $code false_y$$
will be evaluated
(two will be skipped depending on the result of $code left_z == right_z$$).
Not all of the expressions corresponding to
$code left_x$$, $code right_x$$, $code left_y$$, $code right_y$$ need to be
evaluate, but they are.
The optimizer could be improved to skip two more expressions
(depending on the result of $code left_z == right_z$$).

$head Forward Mode Recomputation$$
If the results of $cref forward_order$$ have already been computed and are still
stored in the $cref ADFun$$ object (see $cref size_order$$),
then they do not need to be recomputed and the results can just be returned.

$head Iterator Interface$$
All of the CppAD simple vector interfaces should also have an
iterator version for the following reasons:
$list number$$
It would not be necessary to copy information to simple vectors
when it was originally stored in a different type of container.
$lnext
It would not be necessary to reallocate memory for a result that is
repeatedly calculated
(because an iterator for the result container would be passed in).
$lend

$head Compilation Speed$$
One could build a CppAD library for use with the type $code AD<double>$$.
This would speed up compilation for the most common usage where
the $icode Base$$ type is $code double$$.


$head Operation Sequence$$
It is possible to detect if the
AD of $icode Base$$
$cref/operation sequence/glossary/Operation/Sequence/$$
does not depend on any of the
$cref/independent variable/glossary/Tape/Independent Variable/$$ values.
This could be returned as an extra
$cref seq_property$$.

$head Comparison Changes and Optimization$$
The comparison operators used to not be taped when
$cref/NDEBUG/Faq/Speed/NDEBUG/$$ was defined.
They are now taped so that the $cref compare_change$$ interface
works even for compiler optimize code.
This caused a significant slow down in the
$cref cppad_det_lu.cpp$$ speed test (with no options specified).
Perhaps there should be an option to skip the comparison taping.

$head Preprocessor Symbols$$
Make sure all the user API preprocessor symbols are listed in
the $cref preprocessor$$ section.

$head Software Guidelines$$
The following is a list of some software guidelines taken from
$href%http://www.boost.org/development/requirements.html#Guidelines%boost%$$.
These guidelines are not followed by the current CppAD source code,
but perhaps they should be:

$list number$$
Names (except as noted below)
should be all lowercase, with words separated by underscores.
For example, acronyms should be treated as ordinary names
(xml_parser instead of XML_parser).

$lnext
Template parameter names should begin with an uppercase letter.

$lnext
Use spaces rather than tabs.
Currently, CppAD uses a tabs stops at column multiples of 5.
Five columns were chosen to avoid high levels of indenting and to allow for
$codep
	if( expression )
		statement
	else	statement
$$
with a tab after the else.
Automatic conversion to actual spaces should be easy.

$lend

$head Tracing$$
Add tracing the operation sequence to the user API and documentation.
Tracing the operation sequence is currently done by changing the CppAD
source code. Use the command
$codep
	grep '^# *define *CPPAD_.*_TRACE' cppad/local/*.hpp
$$
to find all the possible tracing flags.


$head atan2$$
The $cref/atan2/Atan2/$$ function could be made faster by adding
a special operator for it.


$head BenderQuad$$
See the $cref/problem/BenderQuad/Problem/$$ with the
current $code BenderQuad$$ specifications.

$end
